import React, { useState, useEffect, useCallback, useRef } from "react";
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Animated,
  RefreshControl,
  ActivityIndicator,
  StatusBar,
  Platform,
  Dimensions,
} from "react-native";
import {
  collection,
  onSnapshot,
  query,
  getDocs,
  where,
  Timestamp,
} from "firebase/firestore";
import { auth, db } from "../../../../config/firebaseconfig";
import {
  format,
  startOfWeek,
  addDays,
  addWeeks,
  subWeeks,
  isSameDay,
  isWithinInterval,
  differenceInDays,
  isPast,
  isFuture,
  isValid,
} from "date-fns";
import { Feather } from "@expo/vector-icons";

// Import our custom components
import Header from "../../../../components/Dashboard/Header";
import WeekCalendar from "../../../../components/Dashboard/WeekCalendar";
import {
  EventCard,
  UpcomingEventCard,
} from "../../../../components/Dashboard/EventCard";
import SearchBar from "../../../../components/Dashboard/SearchBar";
import LoadingState from "../../../../components/Dashboard/LoadingState";

// Constants
const EVENT_COLORS = [
  "#4F46E580",
  "#6D28D980",
  "#475569C0",
  "#22D3EE80",
  "#064E3BC0",
  "#14532DC0",
  "#713F12C0",
  "#78350FC0",
  "#762B91C0",
  "#3F3F46C0",
  "#5B21B6C0",
  "#4338CA80",
  "#1E293BC0",
  "#15803DC0",
  "#854D0EC0",
  "#831843C0",
  "#881337C0",
  "#57534EC0",
  "#525252C0",
  "#994F0FC0",
];

// Helper function to safely format dates
const safeFormat = (date, formatString) => {
  try {
    if (!date || !isValid(date)) return "";
    return format(date, formatString);
  } catch (error) {
    console.log("Date formatting error:", error);
    return "";
  }
};

// Helper function to safely convert Firebase timestamp to Date
const safeTimestampToDate = (timestamp) => {
  try {
    if (!timestamp) return null;
    if (timestamp.toDate && typeof timestamp.toDate === 'function') {
      const date = timestamp.toDate();
      if (isValid(date)) return date;
    }
    return null;
  } catch (error) {
    console.log("Timestamp conversion error:", error);
    return null;
  }
};

const Home = () => {
  // ========== STATE MANAGEMENT ==========
  // User data state
  const [username, setUsername] = useState("");
  const [isAdmin, setIsAdmin] = useState(false);

  // Events state
  const [events, setEvents] = useState([]); // Events for the selected date
  const [allEvents, setAllEvents] = useState([]); // All events for the week
  const [upcomingEvents, setUpcomingEvents] = useState([]);
  const [filteredEvents, setFilteredEvents] = useState([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);
  const [expandedEvents, setExpandedEvents] = useState({}); // Track expanded state for each event

  // UI state
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [showWeather, setShowWeather] = useState(true);
  const [weatherData, setWeatherData] = useState({
    temp: "24Â°C",
    condition: "Sunny",
    icon: "sun",
  });

  // Calendar state
  const [weekDays, setWeekDays] = useState([]);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [weekStart, setWeekStart] = useState(
    startOfWeek(new Date(), { weekStartsOn: 1 })
  );

  // Animation values
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(50)).current;

  // Check user role and fetch user data
  const checkUserAndFetchData = async () => {
    try {
      const currentUser = auth.currentUser;
      if (currentUser) {
        const adminDoc = await getDocs(
          query(collection(db, "admin"), where("uid", "==", currentUser.uid))
        );

        if (!adminDoc.empty) {
          setIsAdmin(true);
          setUsername(adminDoc.docs[0].data().username);
        } else {
          const userDoc = await getDocs(
            query(collection(db, "users"), where("uid", "==", currentUser.uid))
          );
          if (!userDoc.empty) {
            setUsername(userDoc.docs[0].data().username);
          }
        }
      }
    } catch (error) {
      console.error("Error checking user role:", error);
    }
  };

  // Define fetchEvents before it's used in other functions
  const fetchEvents = useCallback(async () => {
    try {
      const eventsRef = collection(db, "events");
      const eventsSnapshot = await getDocs(eventsRef);

      const currentWeekStart = startOfWeek(selectedDate, { weekStartsOn: 1 });
      const currentWeekEnd = addDays(currentWeekStart, 6);

      const allFetchedEvents = eventsSnapshot.docs.map((doc) => {
        const data = doc.data();
        const eventDate = safeTimestampToDate(data.dueDate) || new Date();
        
        return {
          id: doc.id,
          ...data,
          eventDate,
          formattedDate: safeFormat(eventDate, "MMM d, yyyy"),
          formattedTime: data.timeframe || safeFormat(eventDate, "h:mm a"),
          color: EVENT_COLORS[Math.floor(Math.random() * EVENT_COLORS.length)],
        };
      });

      // Filter events that fall within the current week
      const eventsInWeek = allFetchedEvents.filter((event) => {
        try {
          return event.eventDate && isWithinInterval(event.eventDate, {
            start: currentWeekStart,
            end: currentWeekEnd,
          });
        } catch (error) {
          console.log("Week interval check error:", error);
          return false;
        }
      });

      // Filter today's events
      const todayEvents = allFetchedEvents.filter((event) => {
        try {
          return event.eventDate && isSameDay(event.eventDate, new Date());
        } catch (error) {
          console.log("Today's events filter error:", error);
          return false;
        }
      });

      setEvents(todayEvents); // Events for today
      setAllEvents(allFetchedEvents); // Store all events for the week

      // Update the weekDays state
      const weekDaysWithEvents = Array.from({ length: 7 }, (_, i) => {
        const date = addDays(currentWeekStart, i);
        return {
          date,
          dayNumber: safeFormat(date, "d"),
          dayName: safeFormat(date, "E"),
          isSelected: isSameDay(date, selectedDate),
          hasEvents: eventsInWeek.some((event) => {
            try {
              return event.eventDate && isSameDay(event.eventDate, date);
            } catch (error) {
              return false;
            }
          }),
        };
      });

      setWeekDays(weekDaysWithEvents);
    } catch (error) {
      console.error("Error fetching events:", error);
    }
  }, [selectedDate]);

  // Pull-to-refresh functionality
  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    try {
      await Promise.all([fetchEvents(), checkUserAndFetchData()]);

      // Animate elements when refreshed
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 800,
          useNativeDriver: true,
        }),
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 600,
          useNativeDriver: true,
        }),
      ]).start();
    } catch (error) {
      console.error("Error refreshing data:", error);
    } finally {
      setRefreshing(false);
    }
  }, [fetchEvents, fadeAnim, slideAnim]);

  // Initial data fetch
  const fetchData = async () => {
    setLoading(true);
    try {
      // Create a promise that resolves after fetchEvents or after a timeout
      const fetchWithTimeout = Promise.race([
        fetchEvents(),
        new Promise((resolve) => setTimeout(resolve, 5000)), // 5 second timeout
      ]);

      await fetchWithTimeout;

      // Animate elements when data is loaded
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 800,
          useNativeDriver: true,
        }),
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 600,
          useNativeDriver: true,
        }),
      ]).start();
    } catch (error) {
      console.error("Error fetching data:", error);
    } finally {
      // Ensure loading state is turned off even if there's an error
      setLoading(false);
    }
  };

  // Search functionality - optimized
  const handleSearch = useCallback(
    (text) => {
      setSearchQuery(text);
      if (text.trim() === "") {
        setFilteredEvents([]);
        setIsSearching(false);
        return;
      }

      setIsSearching(true);
      const query = text.toLowerCase();
      const results = allEvents.filter(
        (event) =>
          event.title?.toLowerCase().includes(query) ||
          event.description?.toLowerCase().includes(query)
      );
      setFilteredEvents(results);
    },
    [allEvents]
  );

  // Define setupRealtimeUpdates before using it in useEffect
  const setupRealtimeUpdates = useCallback(() => {
    const eventsRef = collection(db, "events");
    const q = query(eventsRef);

    const unsubscribe = onSnapshot(q, (snapshot) => {
      // Process all events with enhanced data
      const allEvents = snapshot.docs.map((doc) => {
        const data = doc.data();
        const eventDate = safeTimestampToDate(data.dueDate) || new Date();
        const today = new Date();
        const isPastEvent = isPast(eventDate) && !isSameDay(eventDate, today);

        // Calculate days remaining until event
        let daysRemaining = 0;
        try {
          daysRemaining = differenceInDays(eventDate, today);
        } catch (error) {
          console.log("Days remaining calculation error:", error);
        }

        // Assign a color based on time proximity or past status
        let color;
        if (isPastEvent) {
          color = "#9CA3AF80"; // Gray for past events
        } else if (daysRemaining === 0) {
          color = "#EF444480"; // Red for today's events
        } else if (daysRemaining <= 2) {
          color = "#F59E0B80"; // Orange for soon events
        } else {
          color = EVENT_COLORS[Math.floor(Math.random() * EVENT_COLORS.length)];
        }

        return {
          id: doc.id,
          ...data,
          color,
          eventDate,
          isPastEvent,
          daysRemaining: daysRemaining < 0 ? 0 : daysRemaining,
          formattedDate: safeFormat(eventDate, "MMM d, yyyy"),
          formattedTime: data.timeframe || safeFormat(eventDate, "h:mm a"),
        };
      });

      // Set all events
      setAllEvents(allEvents);

      // Update week days directly
      const currentWeekStart = startOfWeek(selectedDate, { weekStartsOn: 1 });
      const weekEnd = addDays(currentWeekStart, 6);

      const eventsInWeek = allEvents.filter((event) => {
        try {
          return event.eventDate && isWithinInterval(event.eventDate, {
            start: currentWeekStart,
            end: weekEnd,
          });
        } catch (error) {
          console.log("Week interval check error:", error);
          return false;
        }
      });

      // Update weekDays directly instead of using updateWeekDaysWithEvents
      const weekDaysWithEvents = Array.from({ length: 7 }, (_, i) => {
        const date = addDays(currentWeekStart, i);
        return {
          date,
          dayNumber: safeFormat(date, "d"),
          dayName: safeFormat(date, "E"),
          isSelected: isSameDay(date, selectedDate),
          hasEvents: eventsInWeek.some((event) => {
            try {
              return event.eventDate && isSameDay(event.eventDate, date);
            } catch (error) {
              return false;
            }
          }),
        };
      });

      setWeekDays(weekDaysWithEvents);

      // Filter events for the selected date
      const selectedDayEvents = allEvents.filter((event) => {
        try {
          return event.eventDate && isSameDay(event.eventDate, selectedDate);
        } catch (error) {
          console.log("Selected day filter error:", error);
          return false;
        }
      });

      // Filter upcoming events - exclude today's events
      const upcomingEvents = allEvents
        .filter((event) => {
          try {
            return (
              event.eventDate &&
              isFuture(event.eventDate) &&
              !isSameDay(event.eventDate, new Date())
            );
          } catch (error) {
            console.log("Upcoming event filter error:", error);
            return false;
          }
        })
        .sort((a, b) => {
          // Safe sorting
          if (!a.eventDate) return 1;
          if (!b.eventDate) return -1;
          return a.eventDate - b.eventDate;
        })
        .slice(0, 5); // Top 5 upcoming events

      setEvents(selectedDayEvents);
      setUpcomingEvents(upcomingEvents);

      // Update search results if search is active
      if (searchQuery.trim() !== "") {
        handleSearch(searchQuery);
      }
    });

    return unsubscribe;
  }, [selectedDate, searchQuery, handleSearch]);

  const timeToDecimalHours = (timeStr) => {
    if (!timeStr) return 0;
    
    try {
      const [time, period] = timeStr.split(" ");
      const [hours, minutes] = time.split(":").map(Number);
      let decimalHours = hours || 0;

      if (minutes) {
        decimalHours += minutes / 60;
      }

      if (period === "PM" && hours !== 12) {
        decimalHours += 12;
      } else if (period === "AM" && hours === 12) {
        decimalHours = minutes / 60;
      }

      return decimalHours;
    } catch (error) {
      console.log("Time conversion error:", error);
      return 0;
    }
  };

  // Convert time string to minutes for sorting
  const convertToTimeValue = (time) => {
    if (!time) return 0;
    
    try {
      const matches = time.match(/(\d+):(\d+)\s?(AM|PM)/i);
      if (!matches) return 0;

      const [hour, minute, period] = matches.slice(1);
      let hours = parseInt(hour, 10) || 0;
      const minutes = parseInt(minute, 10) || 0;
      if (period.toUpperCase() === "PM" && hours !== 12) hours += 12;
      if (period.toUpperCase() === "AM" && hours === 12) hours = 0;
      return hours * 60 + minutes;
    } catch (error) {
      console.log("Time value conversion error:", error);
      return 0;
    }
  };

  const generateWeekDays = useCallback(
    (startDate) => {
      return Array.from({ length: 7 }, (_, i) => {
        const date = addDays(startDate, i);
        return {
          date,
          dayNumber: safeFormat(date, "d"),
          dayName: safeFormat(date, "E"),
          isSelected: isSameDay(date, selectedDate),
          hasEvents: false,
        };
      });
    },
    [selectedDate]
  );

  // This function is kept for reference but we're not using it directly anymore
  // to avoid circular dependencies
  const updateWeekDaysWithEvents = useCallback(
    (eventsInWeek) => {
      const weekDaysWithEvents = generateWeekDays(weekStart).map((day) => ({
        ...day,
        hasEvents: eventsInWeek.some((event) => {
          try {
            return event.eventDate && isSameDay(event.eventDate, day.date);
          } catch (error) {
            return false;
          }
        }),
      }));
      setWeekDays(weekDaysWithEvents);
    },
    [generateWeekDays, weekStart]
  );

  const handlePreviousWeek = useCallback(() => {
    const newWeekStart = subWeeks(weekStart, 1);
    setWeekStart(newWeekStart);

    // Update week days for the new week with safe date handling
    const newWeekDays = Array.from({ length: 7 }, (_, i) => {
      const date = addDays(newWeekStart, i);
      return {
        date,
        dayNumber: safeFormat(date, "d"),
        dayName: safeFormat(date, "E"),
        isSelected: isSameDay(date, selectedDate),
        hasEvents: allEvents.some((event) => {
          try {
            // Use the already processed eventDate property
            return event.eventDate && isSameDay(event.eventDate, date);
          } catch (error) {
            console.log("Previous week event check error:", error);
            return false;
          }
        }),
      };
    });

    setWeekDays(newWeekDays);
  }, [weekStart, selectedDate, allEvents]);

  const handleNextWeek = useCallback(() => {
    const newWeekStart = addWeeks(weekStart, 1);
    setWeekStart(newWeekStart);

    // Update week days for the new week
    const newWeekDays = Array.from({ length: 7 }, (_, i) => {
      const date = addDays(newWeekStart, i);
      return {
        date,
        dayNumber: safeFormat(date, "d"),
        dayName: safeFormat(date, "E"),
        isSelected: isSameDay(date, selectedDate),
        hasEvents: allEvents.some((event) => {
          try {
            return event.eventDate && isSameDay(event.eventDate, date);
          } catch (error) {
            return false;
          }
        }),
      };
    });

    setWeekDays(newWeekDays);
  }, [weekStart, selectedDate, allEvents]);

  const handleDateSelect = useCallback(
    (date) => {
      // Prevent unnecessary re-renders if the same date is selected
      if (isSameDay(date, selectedDate)) return;

      // Set the selected date with a small delay to prevent flickering
      requestAnimationFrame(() => {
        setSelectedDate(date);

        // Filter existing events for the selected date with error handling
        const selectedDayEvents = allEvents.filter((event) => {
          try {
            // Use the already processed eventDate property
            return event.eventDate && isSameDay(event.eventDate, date);
          } catch (error) {
            console.log("Date selection filter error:", error);
            return false;
          }
        });

        setEvents(selectedDayEvents);

        // Update the weekDays to mark the selected date
        setWeekDays((prevWeekDays) =>
          prevWeekDays.map((day) => ({
            ...day,
            isSelected: isSameDay(day.date, date),
          }))
        );
      });
    },
    [allEvents, selectedDate]
  );

  const getSectionTitle = useCallback(() => {
    const today = new Date();
    const isToday = isSameDay(selectedDate, today);
    const formattedDate = safeFormat(selectedDate, "MMMM d");

    return isToday ? "Today" : formattedDate;
  }, [selectedDate]);

  const getGreeting = () => {
    const hour = new Date().getHours();
    if (hour < 12) return "Good Morning";
    if (hour < 18) return "Good Afternoon";
    return "Good Evening";
  };

  // Main initialization effect - simplified to avoid glitching
  useEffect(() => {
    const initializeData = async () => {
      try {
        // Fetch events first
        const eventsRef = collection(db, "events");
        const eventsSnapshot = await getDocs(eventsRef);

        // Process events with safe date handling
        const allFetchedEvents = eventsSnapshot.docs.map((doc) => {
          const data = doc.data();
          const eventDate = safeTimestampToDate(data.dueDate);
          
          return {
            id: doc.id,
            ...data,
            eventDate: eventDate || new Date(),
            formattedDate: eventDate ? safeFormat(eventDate, "MMM d, yyyy") : "",
            formattedTime: data.timeframe || (eventDate ? safeFormat(eventDate, "h:mm a") : ""),
            color: EVENT_COLORS[Math.floor(Math.random() * EVENT_COLORS.length)],
          };
        });

        // Update state
        setAllEvents(allFetchedEvents);

        // Filter today's events - using the already processed eventDate
        const todayEvents = allFetchedEvents.filter((event) => {
          try {
            return event.eventDate && isSameDay(event.eventDate, new Date());
          } catch (error) {
            console.log("Date comparison error:", error);
            return false;
          }
        });

        setEvents(todayEvents);

        // Check user data
        const currentUser = auth.currentUser;
        if (currentUser) {
          const adminDoc = await getDocs(
            query(collection(db, "admin"), where("uid", "==", currentUser.uid))
          );

          if (!adminDoc.empty) {
            setIsAdmin(true);
            setUsername(adminDoc.docs[0].data().username);
          } else {
            const userDoc = await getDocs(
              query(
                collection(db, "users"),
                where("uid", "==", currentUser.uid)
              )
            );
            if (!userDoc.empty) {
              setUsername(userDoc.docs[0].data().username);
            }
          }
        }

        // Update week days
        const currentWeekStart = startOfWeek(selectedDate, { weekStartsOn: 1 });
        const weekDaysData = Array.from({ length: 7 }, (_, i) => {
          const date = addDays(currentWeekStart, i);
          return {
            date,
            dayNumber: safeFormat(date, "d"),
            dayName: safeFormat(date, "E"),
            isSelected: isSameDay(date, selectedDate),
            hasEvents: allFetchedEvents.some((event) => {
              try {
                // Use the already processed eventDate property
                return event.eventDate && isSameDay(event.eventDate, date);
              } catch (error) {
                console.log("Week day event check error:", error);
                return false;
              }
            }),
          };
        });

        setWeekDays(weekDaysData);

        // Animate elements
        Animated.parallel([
          Animated.timing(fadeAnim, {
            toValue: 1,
            duration: 800,
            useNativeDriver: true,
          }),
          Animated.timing(slideAnim, {
            toValue: 0,
            duration: 600,
            useNativeDriver: true,
          }),
        ]).start();
      } catch (error) {
        console.error("Error initializing data:", error);
      } finally {
        setLoading(false);
      }
    };

    // Start initialization
    initializeData();

    // Set up real-time updates
    const eventsRef = collection(db, "events");
    const unsubscribe = onSnapshot(eventsRef, (snapshot) => {
      if (!snapshot.empty) {
        const updatedEvents = snapshot.docs.map((doc) => {
          const data = doc.data();
          const eventDate = safeTimestampToDate(data.dueDate);
          const today = new Date();

          // Calculate days remaining until event
          let daysRemaining = 0;
          try {
            if (eventDate) {
              daysRemaining = differenceInDays(eventDate, today);
            }
          } catch (error) {
            console.log("Days remaining calculation error:", error);
          }

          // Determine if it's a past event
          let isPastEvent = false;
          try {
            if (eventDate) {
              isPastEvent = isPast(eventDate) && !isSameDay(eventDate, today);
            }
          } catch (error) {
            console.log("Past event check error:", error);
          }

          // Assign a color based on time proximity or past status
          let color;
          if (isPastEvent) {
            color = "#9CA3AF80"; // Gray for past events
          } else if (daysRemaining === 0) {
            color = "#EF444480"; // Red for today's events
          } else if (daysRemaining <= 2) {
            color = "#F59E0B80"; // Orange for soon events
          } else {
            color = EVENT_COLORS[Math.floor(Math.random() * EVENT_COLORS.length)];
          }

          return {
            id: doc.id,
            ...data,
            eventDate: eventDate || new Date(),
            isPastEvent,
            daysRemaining: daysRemaining < 0 ? 0 : daysRemaining,
            formattedDate: eventDate ? safeFormat(eventDate, "MMM d, yyyy") : "",
            formattedTime: data.timeframe || (eventDate ? safeFormat(eventDate, "h:mm a") : ""),
            color,
          };
        });

        setAllEvents(updatedEvents);

        // Update selected date events with error handling
        const selectedDayEvents = updatedEvents.filter((event) => {
          try {
            return event.eventDate && isSameDay(event.eventDate, selectedDate);
          } catch (error) {
            console.log("Selected day filter error:", error);
            return false;
          }
        });
        setEvents(selectedDayEvents);

        // Update upcoming events with error handling
        try {
          const upcoming = updatedEvents
            .filter((event) => {
              try {
                return (
                  event.eventDate &&
                  isFuture(event.eventDate) &&
                  !isSameDay(event.eventDate, new Date())
                );
              } catch (error) {
                console.log("Upcoming event filter error:", error);
                return false;
              }
            })
            .sort((a, b) => {
              // Safe sorting
              if (!a.eventDate) return 1;
              if (!b.eventDate) return -1;
              return a.eventDate - b.eventDate;
            })
            .slice(0, 5);
          setUpcomingEvents(upcoming);
        } catch (error) {
          console.log("Upcoming events processing error:", error);
        }
      }
    });

    return () => unsubscribe();
  }, [selectedDate]);

  // Toggle expanded state for a specific event
  const toggleEventExpanded = (eventId) => {
    setExpandedEvents((prev) => ({
      ...prev,
      [eventId]: !prev[eventId],
    }));
  };

  // Event card component with minimalist modern design
  const renderEventCard = (event) => {
    const expanded = expandedEvents[event.id] || false;
    const hasLongDescription =
      event.description && event.description.length > 80;

    return (
      <Animated.View
        key={event.id}
        style={[
          styles.eventCard,
          { opacity: fadeAnim, transform: [{ translateY: slideAnim }] },
        ]}
      >
        <View style={styles.eventTimeIndicator}>
          <Text style={styles.eventTimeText}>{event.formattedTime || "All day"}</Text>
        </View>

        <View style={styles.eventCardContent}>
          <View
            style={[
              styles.eventColorBar,
              { backgroundColor: event.color || "#4F46E5" },
            ]}
          />

          <View style={styles.eventMainContent}>
            <Text style={styles.eventTitle}>{event.title || "Untitled Event"}</Text>
            {event.description && (
              <>
                <Text
                  style={styles.eventDescription}
                  numberOfLines={expanded ? undefined : 2}
                >
                  {event.description}
                </Text>
                {hasLongDescription && (
                  <TouchableOpacity
                    onPress={() => toggleEventExpanded(event.id)}
                    style={styles.seeMoreButton}
                  >
                    <Text style={styles.seeMoreText}>
                      {expanded ? "See less" : "See more"}
                    </Text>
                  </TouchableOpacity>
                )}
              </>
            )}
          </View>
        </View>
      </Animated.View>
    );
  };

  // Upcoming event card with enhanced styling
  const renderUpcomingEventCard = (event) => {
    const eventDate = event.eventDate;
    const isToday = eventDate && isSameDay(eventDate, new Date());
    const daysRemaining = event.daysRemaining || 0;

    return (
      <Animated.View
        key={event.id}
        style={[
          styles.upcomingEventCard,
          { opacity: fadeAnim, transform: [{ translateY: slideAnim }] },
        ]}
      >
        <View
          style={[
            styles.upcomingEventColorBar,
            { backgroundColor: event.color || "#4F46E5" },
          ]}
        />

        <View style={styles.upcomingEventContent}>
          <Text style={styles.upcomingEventTitle}>{event.title || "Untitled Event"}</Text>

          <View style={styles.upcomingEventDetails}>
            <View style={styles.upcomingEventDateContainer}>
              <Feather name="calendar" size={14} color="#64748B" />
              <Text style={styles.upcomingEventDate}>
                {event.formattedDate || "Date not set"}
              </Text>
            </View>

            {event.formattedTime && (
              <View style={styles.upcomingEventTimeContainer}>
                <Feather name="clock" size={14} color="#64748B" />
                <Text style={styles.upcomingEventTime}>
                  {event.formattedTime}
                </Text>
              </View>
            )}
          </View>

          <View style={styles.upcomingEventStatus}>
            <Text
              style={[
                styles.upcomingEventStatusText,
                {
                  color:
                    daysRemaining === 0
                      ? "#EF4444"
                      : daysRemaining <= 2
                      ? "#F59E0B"
                      : "#3B82F6",
                },
              ]}
            >
              {isToday
                ? "Today"
                : daysRemaining === 1
                ? "Tomorrow"
                : `In ${daysRemaining} days`}
            </Text>
          </View>
        </View>
      </Animated.View>
    );
  };

  const styles = StyleSheet.create({
    // Main container styles
    mainContainer: {
      flex: 1,
      backgroundColor: "#f8f9fa",
    },
    scrollContainer: {
      flex: 1,
      backgroundColor: "#f8f9fa",
    },
    scrollContent: {
      paddingBottom: 20,
    },

    // Loading styles
    loaderContainer: {
      flex: 1,
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "#f8f9fa",
      padding: 20,
    },
    loadingTextDark: {
      marginTop: 15,
      fontSize: 16,
      color: "#203562",
      fontWeight: "500",
      letterSpacing: 0.5,
    },

    // Header styles
    headerContainer: {
      paddingHorizontal: 20,
      paddingTop: Platform.OS === "ios" ? 50 : 20,
      paddingBottom: 15,
      backgroundColor: "#f8f9fa",
    },
    greetingContainer: {
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "center",
      marginBottom: 5,
    },
    greeting: {
      fontSize: 22,
      fontWeight: "700",
      color: "#1e293b",
      letterSpacing: 0.3,
    },
    username: {
      fontSize: 22,
      fontWeight: "700",
      color: "#3b82f6",
      letterSpacing: 0.3,
    },
    dateText: {
      fontSize: 14,
      color: "#64748b",
      marginBottom: 10,
    },
    weatherContainer: {
      flexDirection: "row",
      alignItems: "center",
      backgroundColor: "#e0f2fe",
      paddingHorizontal: 12,
      paddingVertical: 8,
      borderRadius: 12,
      alignSelf: "flex-start",
      marginTop: 5,
    },
    weatherText: {
      fontSize: 14,
      color: "#0369a1",
      marginLeft: 6,
      fontWeight: "500",
    },

    // Calendar styles
    calendarContainer: {
      marginTop: 15,
      paddingHorizontal: 15,
      backgroundColor: "#f8f9fa",
    },
    weekNavigationContainer: {
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "center",
      marginBottom: 10,
      paddingHorizontal: 5,
    },
    weekNavigationButton: {
      padding: 8,
      borderRadius: 8,
      backgroundColor: "#f1f5f9",
    },
    weekNavigationText: {
      fontSize: 15,
      fontWeight: "600",
      color: "#334155",
    },
    weekDaysContainer: {
      flexDirection: "row",
      justifyContent: "space-between",
      paddingHorizontal: 5,
      marginBottom: 15,
    },
    dayContainer: {
      alignItems: "center",
      width: 40,
    },
    dayNameText: {
      fontSize: 12,
      color: "#64748b",
      marginBottom: 5,
    },
    dayNumberContainer: {
      width: 36,
      height: 36,
      borderRadius: 18,
      justifyContent: "center",
      alignItems: "center",
      backgroundColor: "#f1f5f9",
    },
    selectedDayContainer: {
      backgroundColor: "#3b82f6",
    },
    dayNumberText: {
      fontSize: 14,
      fontWeight: "600",
      color: "#334155",
    },
    selectedDayText: {
      color: "#ffffff",
    },
    dayWithEventsIndicator: {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: "#3b82f6",
      marginTop: 4,
    },

    // Section styles
    sectionContainer: {
      marginTop: 25,
      paddingHorizontal: 20,
    },
    sectionHeader: {
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "center",
      marginBottom: 5,
    },
    sectionTitle: {
      fontSize: 18,
      fontWeight: "700",
      color: "#1e293b",
      letterSpacing: 0.3,
    },
    sectionSubtitle: {
      fontSize: 14,
      color: "#64748b",
      marginBottom: 15,
    },
    viewAllButton: {
      paddingVertical: 5,
      paddingHorizontal: 10,
    },
    viewAllText: {
      fontSize: 14,
      color: "#3b82f6",
      fontWeight: "600",
    },

    // Event card styles
    eventsContainer: {
      marginTop: 10,
    },
    eventCard: {
      flexDirection: "row",
      backgroundColor: "#ffffff",
      borderRadius: 12,
      marginBottom: 12,
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2.5,
      elevation: 2,
      overflow: "hidden",
    },
    eventTimeIndicator: {
      width: 60,
      paddingVertical: 15,
      alignItems: "center",
      justifyContent: "flex-start",
    },
    eventTimeText: {
      fontSize: 12,
      fontWeight: "600",
      color: "#64748b",
    },
    eventCardContent: {
      flex: 1,
      flexDirection: "row",
    },
    eventColorBar: {
      width: 4,
      backgroundColor: "#3b82f6",
    },
    eventMainContent: {
      flex: 1,
      padding: 15,
      paddingLeft: 12,
    },
    eventTitle: {
      fontSize: 16,
      fontWeight: "600",
      color: "#1e293b",
      marginBottom: 4,
    },
    eventDescription: {
      fontSize: 14,
      color: "#64748b",
      lineHeight: 20,
    },
    seeMoreButton: {
      marginTop: 5,
      alignSelf: "flex-start",
    },
    seeMoreText: {
      fontSize: 13,
      color: "#3b82f6",
      fontWeight: "600",
    },

    // Upcoming event card styles
    upcomingEventsContainer: {
      marginTop: 10,
    },
    upcomingEventCard: {
      flexDirection: "row",
      backgroundColor: "#ffffff",
      borderRadius: 12,
      marginBottom: 12,
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2.5,
      elevation: 2,
      overflow: "hidden",
    },
    upcomingEventColorBar: {
      width: 4,
      backgroundColor: "#3b82f6",
    },
    upcomingEventContent: {
      flex: 1,
      padding: 15,
      paddingLeft: 12,
    },
    upcomingEventTitle: {
      fontSize: 15,
      fontWeight: "600",
      color: "#1e293b",
      marginBottom: 6,
    },
    upcomingEventDetails: {
      flexDirection: "row",
      alignItems: "center",
      flexWrap: "wrap",
    },
    upcomingEventDateContainer: {
      flexDirection: "row",
      alignItems: "center",
      marginRight: 15,
      marginBottom: 4,
    },
    upcomingEventDate: {
      fontSize: 13,
      color: "#64748b",
      marginLeft: 5,
    },
    upcomingEventTimeContainer: {
      flexDirection: "row",
      alignItems: "center",
      marginBottom: 4,
    },
    upcomingEventTime: {
      fontSize: 13,
      color: "#64748b",
      marginLeft: 5,
    },
    upcomingEventStatus: {
      marginTop: 6,
    },
    upcomingEventStatusText: {
      fontSize: 13,
      fontWeight: "600",
      color: "#3b82f6",
    },

    // No events styles
    noEventsContainer: {
      alignItems: "center",
      justifyContent: "center",
      padding: 30,
      backgroundColor: "#f8fafc",
      borderRadius: 12,
      borderWidth: 1,
      borderColor: "#e2e8f0",
      borderStyle: "dashed",
    },
    noEventsText: {
      fontSize: 16,
      fontWeight: "600",
      color: "#64748b",
      marginTop: 10,
    },
    noEventsSubtext: {
      fontSize: 14,
      color: "#94a3b8",
      marginTop: 5,
      textAlign: "center",
    },

    // Search styles
    searchContainer: {
      marginTop: 15,
      paddingHorizontal: 20,
    },
    searchResultsContainer: {
      marginTop: 20,
      paddingHorizontal: 20,
    },
    searchResultsTitle: {
      fontSize: 16,
      fontWeight: "600",
      color: "#1e293b",
      marginBottom: 10,
    },
  });

  return (
    <View style={styles.mainContainer}>
      <StatusBar
        barStyle={Platform.OS === "ios" ? "dark-content" : "light-content"}
        backgroundColor="#f8f9fa"
      />

      {/* Header */}
      <Header
        username={username}
        greeting={getGreeting()}
        weatherData={weatherData}
        showWeather={showWeather}
        toggleWeather={() => setShowWeather(!showWeather)}
      />

      {/* Search Bar */}
      <View style={styles.searchContainer}>
        <SearchBar
          value={searchQuery}
          onChangeText={handleSearch}
          onClear={() => handleSearch("")}
          placeholder="Search events..."
        />
      </View>

      {/* Main Content */}
      <ScrollView
        style={styles.scrollContainer}
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        {loading ? (
          <LoadingState message="Loading your schedule..." />
        ) : isSearching ? (
          <View style={styles.searchResultsContainer}>
            <Text style={styles.searchResultsTitle}>
              {filteredEvents.length === 0
                ? "No results found"
                : `Found ${filteredEvents.length} result${
                    filteredEvents.length === 1 ? "" : "s"
                  }`}
            </Text>

            <View style={styles.eventsContainer}>
              {filteredEvents.length > 0 ? (
                filteredEvents.map((event) => renderEventCard(event))
              ) : (
                <Text style={styles.noEventsText}>
                  No events match your search
                </Text>
              )}
            </View>
          </View>
        ) : (
          <>
            {/* Calendar */}
            <View style={styles.calendarContainer}>
              <View style={styles.weekNavigationContainer}>
                <TouchableOpacity
                  style={styles.weekNavigationButton}
                  onPress={handlePreviousWeek}
                >
                  <Feather name="chevron-left" size={20} color="#334155" />
                </TouchableOpacity>
                <Text style={styles.weekNavigationText}>
                  {safeFormat(weekStart, "MMMM yyyy")}
                </Text>
                <TouchableOpacity
                  style={styles.weekNavigationButton}
                  onPress={handleNextWeek}
                >
                  <Feather name="chevron-right" size={20} color="#334155" />
                </TouchableOpacity>
              </View>

              <WeekCalendar
                weekDays={weekDays}
                onSelectDate={handleDateSelect}
              />
            </View>

            {/* Today's Events Section */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Text style={styles.sectionTitle}>{getSectionTitle()}</Text>
              </View>

              <Text style={styles.sectionSubtitle}>
                {events.length === 0
                  ? "No events scheduled for this day"
                  : `You have ${events.length} event${
                      events.length === 1 ? "" : "s"
                    } scheduled`}
              </Text>

              <View style={styles.eventsContainer}>
                {events.length > 0 ? (
                  events
                    .sort((a, b) => {
                      return (
                        convertToTimeValue(a.timeframe) -
                        convertToTimeValue(b.timeframe)
                      );
                    })
                    .map((event) => renderEventCard(event))
                ) : (
                  <View style={styles.noEventsContainer}>
                    <Feather name="calendar" size={40} color="#DDD" />
                    <Text style={styles.noEventsText}>No scheduled events</Text>
                    <Text style={styles.noEventsSubtext}>
                      Enjoy your free time!
                    </Text>
                  </View>
                )}
              </View>
            </View>

            {/* Upcoming Events Section */}
            <View style={styles.sectionContainer}>
              <View style={styles.sectionHeader}>
                <Text style={styles.sectionTitle}>Upcoming Events</Text>
              </View>

              <Text style={styles.sectionSubtitle}>
                Be prepared for your scheduled events ahead
              </Text>

              <View style={styles.upcomingEventsContainer}>
                {upcomingEvents.length > 0 ? (
                  upcomingEvents.map((event) => renderUpcomingEventCard(event))
                ) : (
                  <View style={styles.noEventsContainer}>
                    <Feather name="calendar" size={40} color="#DDD" />
                    <Text style={styles.noEventsText}>No upcoming events</Text>
                    <Text style={styles.noEventsSubtext}>
                      Your schedule is clear
                    </Text>
                  </View>
                )}
              </View>
            </View>
          </>
        )}
        {/* Bottom padding for better scrolling */}
        <View style={{ height: 30 }} />
      </ScrollView>
    </View>
  );
};

export default Home;